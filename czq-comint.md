# CZQ Comint Filter Notes

This document captures a quick walkthrough for experimenting with the CZQ
comint pre-output filter and its handler dispatch helpers.  It mirrors the
workflow you can run inside `*scratch*` while developing.

## Quick Setup
- Ensure both `czq-xml-parser.el` and `czq-comint.el` are loaded: `(require 'czq-comint)`.
- Optional: enable debug logging to watch handler dispatch decisions.

```elisp
(setq czq-comint-debug t)
```

## Scratch Snippets

Start a fresh buffer state and feed it simulated terminal output:

```elisp
(let ((output "<czq-comint handler=\"elisp\" results=\"true\">(+ 1 2)</czq-comint>"))
  (with-temp-buffer
    (czq-comint-mode)
    (list
     :result (czq-comint--preoutput-filter output)
     :state  (czq-xml-parser-format-state czq-comint--parser-state))))
```

- `:result` shows what will be inserted into the comint buffer (`"3\n"` in the example).
- `:state` prints the parser summary after the chunk is processed.

To observe streaming behaviour, split the tag across chunks:

```elisp
(with-temp-buffer
  (czq-comint-mode)
  (list
   (czq-comint--preoutput-filter "<czq-comint handler=\"el")
   (czq-comint--preoutput-filter "isp\" results=\"true\">(+ 4 5)</czq-comint>")
   (czq-xml-parser-format-state czq-comint--parser-state)))
```

The list returned is `("" "9\n" STATE)` which confirms the first chunk keeps
the parser mid-tag and the second produces the handler output.

By default the built-in `elisp` handler evaluates code for its side effects only.
Add `results="true"` (or any `true`/`yes` style value) to surface the printed
result; errors always surface regardless of the attribute.

## Launching Sessions

Configure per-buffer startup commands by extending
`czq-comint-command-alist`.  Each entry matches a substring in the buffer
name you pass to `czq-comint-run`.  When matched, the command is injected into
the new bash session once it starts; otherwise the shell opens without extra
input.

```elisp
(setq czq-comint-command-alist
      '(("python" . "python3")
        ("sql"    . "psql")))
```

Then invoke:

```elisp
(czq-comint-run "*CZQ Python*") ; runs python3 inside bash
(czq-comint-run "*CZQ Notes*")  ; plain bash shell
```

`czq-comint-run` captures the directory from which you issue the command,
instructs the shell to `cd` there, and records the location in the buffer-local
`czq-comint-current-directory`.  To double-check the tracked path, call:

```elisp
(czq-comint-dirtrack-display-current-directory)
```

The helper displays the cached directory in the echo area, which is especially
useful when prompts are heavily customised or when completions depend on the
current `pwd`.

## PATH-aware Completion

CZQ comint installs a custom completion backend that draws from both a
customizable command list (`czq-comint-completion-command-list`) and the
executables discovered on the buffer’s `$PATH`.  The path scan happens when the
mode starts, but you can ask the running shell for its live `$PATH` at any time:

```elisp
(czq-comint-completion-refresh-from-process)
```

This is particularly handy after running `export PATH=…` within the REPL.  The
command redirects a `printf` into the process, parses the resulting path, and
refreshes the cached completion candidates in place.

Buffer-local helpers you may want to inspect during development:

- `czq-comint-current-directory` — updated by the prompt tracker and used to
  scope filesystem completion.
- `czq-comint-completion--cached-commands` — current completion candidates;
  regenerated by `czq-comint-completion-refresh` and
  `czq-comint-completion-refresh-from-process`.

## Running Tests

Run both parser and comint filter tests together:

```sh
emacs --batch -L . \
  -l czq-xml-parser-tests.el \
  -l czq-comint-tests.el \
  -f ert-run-tests-batch-and-exit
```

All tests should report as passing.  Failures will appear with tracebacks that
include the offending comint handler or parser state for easy debugging.
